<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chord Shape Validation - SPEC 010</title>
  <style>
    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: #1a1a2e;
      color: #eee;
      padding: 2rem;
      margin: 0;
    }
    h1 {
      text-align: center;
      margin-bottom: 0.5rem;
    }
    .subtitle {
      text-align: center;
      color: #888;
      margin-bottom: 2rem;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 1.5rem;
      max-width: 1400px;
      margin: 0 auto;
    }
    .card {
      background: #252538;
      border-radius: 8px;
      padding: 1rem;
      text-align: center;
    }
    .chord-name {
      font-size: 1.2rem;
      font-weight: bold;
      margin-bottom: 0.25rem;
    }
    .chord-notes {
      font-size: 0.8rem;
      color: #888;
      margin-bottom: 0.5rem;
    }
    .chord-quality {
      font-size: 0.7rem;
      color: #aaa;
      margin-top: 0.25rem;
    }
    svg {
      display: block;
      margin: 0 auto;
    }
    .legend {
      max-width: 800px;
      margin: 2rem auto;
      padding: 1rem;
      background: #252538;
      border-radius: 8px;
    }
    .legend h3 {
      margin-top: 0;
    }
    .legend-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 1rem;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.85rem;
    }
    .section-title {
      grid-column: 1 / -1;
      font-size: 1.1rem;
      color: #888;
      margin-top: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid #333;
    }
  </style>
</head>
<body>
  <h1>Chord Shape Validation</h1>
  <p class="subtitle">SPEC 010 Visual Vocabulary - Hub-Styled Shape (v3.3)</p>

  <div class="legend">
    <h3>Reading Chord Shapes</h3>
    <div class="legend-grid">
      <div class="legend-item"><strong>Root is always at 12 o'clock</strong></div>
      <div class="legend-item"><strong>Intervals go clockwise</strong></div>
      <div class="legend-item"><strong>Each hour = one semitone</strong></div>
    </div>
    <hr style="border: none; border-top: 1px solid #444; margin: 1rem 0;">
    <h4 style="margin: 0 0 0.5rem 0;">Arm Length = Harmonic Role</h4>
    <div class="legend-grid">
      <div class="legend-item">Long arms: triadic tones (root, 3rd, 5th)</div>
      <div class="legend-item">Medium arms: 7ths (harmonic color)</div>
      <div class="legend-item">Short arms: extensions (9th, 11th, 13th)</div>
    </div>
    <hr style="border: none; border-top: 1px solid #444; margin: 1rem 0;">
    <h4 style="margin: 0 0 0.5rem 0;">Hub Shape = Triadic Quality</h4>
    <div class="legend-grid">
      <div class="legend-item">Smooth circle: major (stable, bright)</div>
      <div class="legend-item">Wavy edge: minor (darker, introspective)</div>
      <div class="legend-item">Pinched inward: diminished (tense, unstable)</div>
      <div class="legend-item">Bulging outward: augmented (expansive, unresolved)</div>
      <div class="legend-item">Dashed edge: suspended (seeking resolution)</div>
    </div>
    <hr style="border: none; border-top: 1px solid #444; margin: 1rem 0;">
    <h4 style="margin: 0 0 0.5rem 0;">Chromatic Alterations</h4>
    <p style="font-size: 0.85rem; color: #aaa; margin: 0;">Chromatic tones (like ‚ôØ9) appear as red lines emerging from the hub, distinct from the filled arms.</p>
  </div>

  <div class="grid" id="chord-grid">
    <div class="section-title">Triads</div>
  </div>

  <script>
    // SPEC 010 Constants
    const INTERVAL_ANGLES = {
      0: 0, 1: 30, 2: 60, 3: 90, 4: 120, 5: 150,
      6: 180, 7: 210, 8: 240, 9: 270, 10: 300, 11: 330,
    };

    const HUB_RADIUS = 0.3;
    const ARM_LENGTH = {
      triadic: 0.7,
      seventh: 0.45,
      extension: 0.25,
    };
    const BASE_WIDTH = 30; // degrees

    const INTERVAL_LABELS = {
      0: "1", 1: "‚ô≠2", 2: "2", 3: "‚ô≠3", 4: "3", 5: "4",
      6: "‚ô≠5", 7: "5", 8: "‚ôØ5", 9: "6", 10: "‚ô≠7", 11: "7",
    };

    function getTier(semitones, quality) {
      // Core triadic tones: root, 3rds, 5ths
      if ([0, 3, 4, 7, 8].includes(semitones)) return "triadic";
      // ‚ô≠5 is triadic when it's THE fifth (diminished chords), not when it's ‚ôØ11
      if (semitones === 6 && ["dim", "dim7", "hdim7"].includes(quality)) return "triadic";
      // 7ths
      if ([10, 11].includes(semitones)) return "seventh";
      // Everything else (extensions, sus tones seeking resolution)
      return "extension";
    }

    function getEdgeStyle(quality) {
      switch (quality) {
        case "maj": case "maj7": case "dom7": return "straight";
        case "min": case "min7": return "wavy";
        case "dim": case "dim7": case "hdim7": return "concave";
        case "aug": return "convex";
        case "sus2": return "dash-short";
        case "sus4": return "dash-long";
        default: return "straight";
      }
    }

    function toRadians(degrees) {
      return ((90 - degrees) * Math.PI) / 180;
    }

    function polarToXY(cx, cy, angle, radius) {
      const rad = toRadians(angle);
      return {
        x: cx + radius * Math.cos(rad),
        y: cy - radius * Math.sin(rad)
      };
    }

    // Generate a styled edge from start to end
    function styledEdge(start, end, style, isLeftEdge, armAngle, hubR, tipR, baseRadius, cx, cy) {
      const length = Math.sqrt((end.x - start.x) ** 2 + (end.y - start.y) ** 2);

      if (style === "straight" || style === "dash-short" || style === "dash-long") {
        return ` L ${end.x.toFixed(1)} ${end.y.toFixed(1)}`;
      }

      if (style === "wavy") {
        // Smooth sine wave along the edge
        const midX = (start.x + end.x) / 2;
        const midY = (start.y + end.y) / 2;

        // Perpendicular direction for wave amplitude
        const dx = end.x - start.x;
        const dy = end.y - start.y;
        const perpX = -dy / length;
        const perpY = dx / length;

        const amp = 4; // wave amplitude

        // 3 control points for smooth S-curve
        const q1x = start.x + dx * 0.25 + perpX * amp;
        const q1y = start.y + dy * 0.25 + perpY * amp;
        const q2x = start.x + dx * 0.5 - perpX * amp;
        const q2y = start.y + dy * 0.5 - perpY * amp;
        const q3x = start.x + dx * 0.75 + perpX * amp;
        const q3y = start.y + dy * 0.75 + perpY * amp;

        const m1x = start.x + dx * 0.33;
        const m1y = start.y + dy * 0.33;
        const m2x = start.x + dx * 0.66;
        const m2y = start.y + dy * 0.66;

        return ` Q ${q1x.toFixed(1)} ${q1y.toFixed(1)} ${m1x.toFixed(1)} ${m1y.toFixed(1)}` +
               ` Q ${q2x.toFixed(1)} ${q2y.toFixed(1)} ${m2x.toFixed(1)} ${m2y.toFixed(1)}` +
               ` Q ${q3x.toFixed(1)} ${q3y.toFixed(1)} ${end.x.toFixed(1)} ${end.y.toFixed(1)}`;
      }

      if (style === "concave") {
        // Deep curve inward - control point closer to center
        const midX = (start.x + end.x) / 2;
        const midY = (start.y + end.y) / 2;

        // Direction toward center
        const toCenterX = cx - midX;
        const toCenterY = cy - midY;
        const toCenterLen = Math.sqrt(toCenterX ** 2 + toCenterY ** 2);

        // Move control point toward center (more exaggerated)
        const depth = 12;
        const ctrlX = midX + (toCenterX / toCenterLen) * depth;
        const ctrlY = midY + (toCenterY / toCenterLen) * depth;

        return ` Q ${ctrlX.toFixed(1)} ${ctrlY.toFixed(1)} ${end.x.toFixed(1)} ${end.y.toFixed(1)}`;
      }

      if (style === "convex") {
        // Curve outward - control point away from center
        const midX = (start.x + end.x) / 2;
        const midY = (start.y + end.y) / 2;

        // Direction away from center
        const fromCenterX = midX - cx;
        const fromCenterY = midY - cy;
        const fromCenterLen = Math.sqrt(fromCenterX ** 2 + fromCenterY ** 2);

        const bulge = 8;
        const ctrlX = midX + (fromCenterX / fromCenterLen) * bulge;
        const ctrlY = midY + (fromCenterY / fromCenterLen) * bulge;

        return ` Q ${ctrlX.toFixed(1)} ${ctrlY.toFixed(1)} ${end.x.toFixed(1)} ${end.y.toFixed(1)}`;
      }

      return ` L ${end.x.toFixed(1)} ${end.y.toFixed(1)}`;
    }

    // Generate styled arc along hub between arms
    function styledArc(startAngle, endAngle, hubR, style, cx, cy) {
      // Calculate arc span (going clockwise)
      let arcSpan = endAngle - startAngle;
      if (arcSpan < 0) arcSpan += 360;

      const start = polarToXY(cx, cy, startAngle, hubR);
      const end = polarToXY(cx, cy, endAngle, hubR);

      if (style === "straight" || style === "dash-short" || style === "dash-long") {
        // Simple arc
        const largeArc = arcSpan > 180 ? 1 : 0;
        return ` A ${hubR.toFixed(1)} ${hubR.toFixed(1)} 0 ${largeArc} 1 ${end.x.toFixed(1)} ${end.y.toFixed(1)}`;
      }

      if (style === "wavy") {
        // Wavy arc - smooth sine wave with more waves
        const steps = Math.max(3, Math.floor(arcSpan / 20));
        let path = '';
        const amp = 4;

        for (let i = 0; i < steps; i++) {
          const t0 = i / steps;
          const t1 = (i + 1) / steps;
          const angle0 = startAngle + arcSpan * t0;
          const angle1 = startAngle + arcSpan * t1;
          const midAngle = (angle0 + angle1) / 2;

          const p1 = polarToXY(cx, cy, angle1, hubR);

          // Wave in/out alternating
          const waveR = hubR + (i % 2 === 0 ? amp : -amp);
          const ctrl = polarToXY(cx, cy, midAngle, waveR);

          path += ` Q ${ctrl.x.toFixed(1)} ${ctrl.y.toFixed(1)} ${p1.x.toFixed(1)} ${p1.y.toFixed(1)}`;
        }
        return path;
      }

      if (style === "concave") {
        // Concave = always curves INWARD (sweep=0)
        // Small gaps: pronounced concave dip
        // Large gaps (150¬∞+): flat line to avoid awkward hub bulge
        if (arcSpan >= 150) {
          // Just use a straight line for very large gaps
          return ` L ${end.x.toFixed(1)} ${end.y.toFixed(1)}`;
        }

        const chordLen = Math.sqrt((end.x - start.x) ** 2 + (end.y - start.y) ** 2);
        const minR = chordLen / 2 + 1; // minimum to connect endpoints

        // Scale radius up for larger gaps - gentler concave
        const scaleFactor = 1 + arcSpan * 0.03;
        const targetR = hubR * scaleFactor;
        const concaveR = Math.max(targetR, minR);

        const largeArc = arcSpan > 180 ? 1 : 0;
        // sweep=0 = curves INWARD (concave)
        return ` A ${concaveR.toFixed(1)} ${concaveR.toFixed(1)} 0 ${largeArc} 0 ${end.x.toFixed(1)} ${end.y.toFixed(1)}`;
      }

      if (style === "convex") {
        // Convex = dome rising from hub
        // Larger radius = gentler dome, smaller radius = more pronounced bulge
        const expansionFactor = 1.5 + arcSpan * 0.008; // reduced for more visible bulge
        const convexR = hubR * expansionFactor;

        // sweep=1 curves outward (arc center inside/behind the shape)
        return ` A ${convexR.toFixed(1)} ${convexR.toFixed(1)} 0 0 1 ${end.x.toFixed(1)} ${end.y.toFixed(1)}`;
      }

      const largeArc = arcSpan > 180 ? 1 : 0;
      return ` A ${hubR.toFixed(1)} ${hubR.toFixed(1)} 0 ${largeArc} 1 ${end.x.toFixed(1)} ${end.y.toFixed(1)}`;
    }

    // Generate unified shape path
    // Arms always have straight edges; style applies only to hub arcs
    function generateUnifiedShape(intervals, style, baseRadius, cx, cy, quality) {
      const hubR = baseRadius * HUB_RADIUS;

      // Sort intervals by angle
      const sorted = intervals.map(i => ({
        semitones: i.semitones,
        angle: INTERVAL_ANGLES[i.semitones],
        tier: getTier(i.semitones, quality),
        length: ARM_LENGTH[getTier(i.semitones, quality)]
      })).sort((a, b) => a.angle - b.angle);

      let path = '';

      for (let i = 0; i < sorted.length; i++) {
        const curr = sorted[i];
        const next = sorted[(i + 1) % sorted.length];

        const armLeftAngle = curr.angle - BASE_WIDTH / 2;
        const armRightAngle = curr.angle + BASE_WIDTH / 2;
        const tipR = hubR + baseRadius * curr.length;

        const baseLeft = polarToXY(cx, cy, armLeftAngle, hubR);
        const baseRight = polarToXY(cx, cy, armRightAngle, hubR);
        const tip = polarToXY(cx, cy, curr.angle, tipR);

        if (i === 0) {
          path += `M ${baseLeft.x.toFixed(1)} ${baseLeft.y.toFixed(1)}`;
        }

        // Left edge of arm (base to tip) - ALWAYS STRAIGHT
        path += ` L ${tip.x.toFixed(1)} ${tip.y.toFixed(1)}`;

        // Right edge of arm (tip to base) - ALWAYS STRAIGHT
        path += ` L ${baseRight.x.toFixed(1)} ${baseRight.y.toFixed(1)}`;

        // Arc along hub to next arm's left edge - STYLED (this is where quality shows)
        const nextLeftAngle = next.angle - BASE_WIDTH / 2;
        path += styledArc(armRightAngle, nextLeftAngle, hubR, style, cx, cy);
      }

      path += ' Z';
      return path;
    }

    // Generate line for chromatic alterations
    function generateLinePath(angle, baseRadius, cx, cy) {
      const hubR = baseRadius * HUB_RADIUS;
      // Match extension arm length
      const outerR = hubR + baseRadius * ARM_LENGTH.extension;
      // Position so round cap (1.5px for 3px stroke) is exactly hidden behind hub stroke.
      // Stroke is 2px centered on hubR (covers hubR-1 to hubR+1).
      // Cap extends back 1.5px from line start, so start at hubR+0.5
      // means cap spans hubR-1 to hubR+0.5, entirely behind the stroke.
      const innerR = hubR + 0.5;
      const inner = polarToXY(cx, cy, angle, innerR);
      const outer = polarToXY(cx, cy, angle, outerR);
      return `M ${inner.x.toFixed(1)} ${inner.y.toFixed(1)} L ${outer.x.toFixed(1)} ${outer.y.toFixed(1)}`;
    }

    // Generate arm edges path (always solid stroke)
    function generateArmEdges(intervals, baseRadius, cx, cy, quality) {
      const hubR = baseRadius * HUB_RADIUS;
      const sorted = intervals.map(i => ({
        semitones: i.semitones,
        angle: INTERVAL_ANGLES[i.semitones],
        tier: getTier(i.semitones, quality),
        length: ARM_LENGTH[getTier(i.semitones, quality)]
      })).sort((a, b) => a.angle - b.angle);

      let paths = [];
      for (const curr of sorted) {
        const armLeftAngle = curr.angle - BASE_WIDTH / 2;
        const armRightAngle = curr.angle + BASE_WIDTH / 2;
        const tipR = hubR + baseRadius * curr.length;

        const baseLeft = polarToXY(cx, cy, armLeftAngle, hubR);
        const baseRight = polarToXY(cx, cy, armRightAngle, hubR);
        const tip = polarToXY(cx, cy, curr.angle, tipR);

        paths.push(`M ${baseLeft.x.toFixed(1)} ${baseLeft.y.toFixed(1)} L ${tip.x.toFixed(1)} ${tip.y.toFixed(1)} L ${baseRight.x.toFixed(1)} ${baseRight.y.toFixed(1)}`);
      }
      return paths.join(' ');
    }

    // Generate hub arcs path (styled)
    function generateHubArcs(intervals, style, baseRadius, cx, cy, quality) {
      const hubR = baseRadius * HUB_RADIUS;
      const sorted = intervals.map(i => ({
        semitones: i.semitones,
        angle: INTERVAL_ANGLES[i.semitones],
        tier: getTier(i.semitones, quality),
        length: ARM_LENGTH[getTier(i.semitones, quality)]
      })).sort((a, b) => a.angle - b.angle);

      let path = '';
      for (let i = 0; i < sorted.length; i++) {
        const curr = sorted[i];
        const next = sorted[(i + 1) % sorted.length];

        const armRightAngle = curr.angle + BASE_WIDTH / 2;
        const nextLeftAngle = next.angle - BASE_WIDTH / 2;

        const start = polarToXY(cx, cy, armRightAngle, hubR);
        if (i === 0) {
          path += `M ${start.x.toFixed(1)} ${start.y.toFixed(1)}`;
        }
        path += styledArc(armRightAngle, nextLeftAngle, hubR, style, cx, cy);

        // Move to next arc start
        const nextStart = polarToXY(cx, cy, next.angle + BASE_WIDTH / 2, hubR);
        if (i < sorted.length - 1) {
          path += ` M ${nextStart.x.toFixed(1)} ${nextStart.y.toFixed(1)}`;
        }
      }
      return path;
    }

    // Generate SVG for a chord
    function generateChordSVG(chord) {
      const cx = 80, cy = 80;
      const baseRadius = 55;
      const hubR = baseRadius * HUB_RADIUS;
      const edgeStyle = getEdgeStyle(chord.quality);

      const armIntervals = chord.intervals.filter(i => i.style !== "line");
      const lineIntervals = chord.intervals.filter(i => i.style === "line");

      let elements = [];

      // Lines for chromatic alterations - draw FIRST so they appear behind the shape
      for (const interval of lineIntervals) {
        const angle = INTERVAL_ANGLES[interval.semitones];
        const linePath = generateLinePath(angle, baseRadius, cx, cy);
        elements.push(`<path d="${linePath}" fill="none" stroke="#ff6b6b" stroke-width="3" stroke-linecap="round"/>`);
      }

      const isDashed = edgeStyle.startsWith("dash");

      if (isDashed) {
        // For dashed styles: fill shape (no stroke), then separate strokes for arms (solid) and hub (dashed)
        const shapePath = generateUnifiedShape(armIntervals, edgeStyle, baseRadius, cx, cy, chord.quality);
        elements.push(`<path d="${shapePath}" fill="#4a9eff" fill-opacity="0.6" stroke="none"/>`);

        // Arm edges - solid stroke
        const armPath = generateArmEdges(armIntervals, baseRadius, cx, cy, chord.quality);
        elements.push(`<path d="${armPath}" fill="none" stroke="#4a9eff" stroke-width="2" stroke-linejoin="round"/>`);

        // Hub arcs - dashed stroke
        const hubPath = generateHubArcs(armIntervals, edgeStyle, baseRadius, cx, cy, chord.quality);
        const dashArray = edgeStyle === "dash-short" ? "3,3" : "6,3";
        elements.push(`<path d="${hubPath}" fill="none" stroke="#4a9eff" stroke-width="2" stroke-dasharray="${dashArray}"/>`);
      } else {
        // For non-dashed styles: unified path with stroke
        const shapePath = generateUnifiedShape(armIntervals, edgeStyle, baseRadius, cx, cy, chord.quality);
        elements.push(`<path d="${shapePath}" fill="#4a9eff" fill-opacity="0.6" stroke="#4a9eff" stroke-width="2" stroke-linejoin="round"/>`);
      }

      // Labels
      let labels = [];
      for (const interval of chord.intervals) {
        const angle = INTERVAL_ANGLES[interval.semitones];
        // Line intervals use extension length; arms use their tier
        const armLength = interval.style === "line"
          ? ARM_LENGTH.extension
          : ARM_LENGTH[getTier(interval.semitones, chord.quality)];
        const labelR = hubR + baseRadius * armLength + 12;
        const labelPos = polarToXY(cx, cy, angle, labelR);
        const color = interval.style === "line" ? "#ff6b6b" : "#888";
        labels.push(`<text x="${labelPos.x.toFixed(1)}" y="${(labelPos.y + 3).toFixed(1)}" text-anchor="middle" fill="${color}" font-size="9">${INTERVAL_LABELS[interval.semitones]}</text>`);
      }

      return `<svg width="160" height="160" viewBox="0 0 160 160">
        <circle cx="${cx}" cy="${cy}" r="${baseRadius}" fill="none" stroke="#333" stroke-width="0.5"/>
        ${elements.join('\n        ')}
        ${labels.join('\n        ')}
      </svg>`;
    }

    // Derive musical qualities from chord structure
    function getMusicalQualities(chord) {
      const parts = [];

      // Triadic quality
      const triadMap = {
        maj: "major", maj7: "major", dom7: "major",
        min: "minor", min7: "minor",
        dim: "diminished", dim7: "diminished", hdim7: "diminished",
        aug: "augmented",
        sus2: "sus2", sus4: "sus4"
      };
      parts.push(triadMap[chord.quality] || chord.quality);

      // Check for 7th (semitones 9, 10, or 11)
      const has7th = chord.intervals.some(i => [9, 10, 11].includes(i.semitones));
      if (has7th) parts.push("7th");

      // Check for extensions (semitones 1, 2 = 9th; 5 = 11th; 9 could also be 13th context)
      const hasExtension = chord.intervals.some(i =>
        [1, 2, 5].includes(i.semitones) && i.style !== "line"
      );
      if (hasExtension) parts.push("extensions");

      // Check for chromatic alterations (lines)
      const hasChromatic = chord.intervals.some(i => i.style === "line");
      if (hasChromatic) parts.push("chromatic");

      return parts.join(" ¬∑ ");
    }

    // Chord definitions (root-independent - shapes represent interval relationships)
    const chords = [
      // Triads
      { name: "Major", notes: "1-3-5", quality: "maj",
        intervals: [{semitones: 0}, {semitones: 4}, {semitones: 7}] },
      { name: "Minor", notes: "1-‚ô≠3-5", quality: "min",
        intervals: [{semitones: 0}, {semitones: 3}, {semitones: 7}] },
      { name: "Diminished", notes: "1-‚ô≠3-‚ô≠5", quality: "dim",
        intervals: [{semitones: 0}, {semitones: 3}, {semitones: 6}] },
      { name: "Augmented", notes: "1-3-‚ôØ5", quality: "aug",
        intervals: [{semitones: 0}, {semitones: 4}, {semitones: 8}] },
      { name: "Sus2", notes: "1-2-5", quality: "sus2",
        intervals: [{semitones: 0}, {semitones: 2}, {semitones: 7}] },
      { name: "Sus4", notes: "1-4-5", quality: "sus4",
        intervals: [{semitones: 0}, {semitones: 5}, {semitones: 7}] },

      // Seventh chords
      { section: "Seventh Chords" },
      { name: "Major 7th", notes: "1-3-5-7", quality: "maj7",
        intervals: [{semitones: 0}, {semitones: 4}, {semitones: 7}, {semitones: 11}] },
      { name: "Minor 7th", notes: "1-‚ô≠3-5-‚ô≠7", quality: "min7",
        intervals: [{semitones: 0}, {semitones: 3}, {semitones: 7}, {semitones: 10}] },
      { name: "Dominant 7th", notes: "1-3-5-‚ô≠7", quality: "dom7",
        intervals: [{semitones: 0}, {semitones: 4}, {semitones: 7}, {semitones: 10}] },
      { name: "Diminished 7th", notes: "1-‚ô≠3-‚ô≠5-ùÑ´7", quality: "dim7",
        intervals: [{semitones: 0}, {semitones: 3}, {semitones: 6}, {semitones: 9}] },
      { name: "Half-diminished", notes: "1-‚ô≠3-‚ô≠5-‚ô≠7", quality: "hdim7",
        intervals: [{semitones: 0}, {semitones: 3}, {semitones: 6}, {semitones: 10}] },

      // Extended chords
      { section: "Extended Chords" },
      { name: "Major 9th", notes: "1-3-5-7-9", quality: "maj7",
        intervals: [{semitones: 0}, {semitones: 4}, {semitones: 7}, {semitones: 11}, {semitones: 2}] },
      { name: "Dominant 7‚ôØ9", notes: "1-3-5-‚ô≠7-‚ôØ9", quality: "dom7",
        intervals: [{semitones: 0}, {semitones: 4}, {semitones: 7}, {semitones: 10}, {semitones: 3, style: "line"}] },
      { name: "Add9", notes: "1-3-5-9", quality: "maj",
        intervals: [{semitones: 0}, {semitones: 4}, {semitones: 7}, {semitones: 2}] },
    ];

    // Render all chords
    const grid = document.getElementById('chord-grid');
    for (const chord of chords) {
      if (chord.section) {
        const sectionDiv = document.createElement('div');
        sectionDiv.className = 'section-title';
        sectionDiv.textContent = chord.section;
        grid.appendChild(sectionDiv);
        continue;
      }

      const card = document.createElement('div');
      card.className = 'card';
      card.innerHTML = `
        <div class="chord-name">${chord.name}</div>
        <div class="chord-notes">${chord.notes}</div>
        ${generateChordSVG(chord)}
        <div class="chord-quality">${getMusicalQualities(chord)}</div>
      `;
      grid.appendChild(card);
    }
  </script>
</body>
</html>
